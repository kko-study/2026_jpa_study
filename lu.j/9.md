# 9장 값 타입
## 9.1 기본값 타입

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private int age;
}
```

- 값 타입인 name, age 속성은 식별자 값도 없고 생명주기도 회원 엔티티에 의존한다. 
- 자바에서 primitive type 은 절대 공유되지 않는다. 

## 9.2 임베디드 타입 (복합 값 타입)

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @Temporal(TemporalType.DATE) Date startDate;
    @Temporal(TemporalType.DATE) Date endDate;

    private String city;
    private String street;
    private String zipcode;
}
```

- 회원 엔티티는 이름, 근무기간, 집 주소를 가진다. 
- 근무 기간과 집 주소를 가지도록 임베디드 타입을 사용

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @Embedded Period workPeriod;
    @Embedded Address homeAddress;
}

@Embeddable
public class Period {
    @Temporal(TemporalType.DATE) Date startDate;
    @Temporal(TemporalType.DATE) Date endDate;

    public boolean isWork(Date date) {

    }
}

@Embeddable
public class Address {
    @Column(name = "city")
    private String city;
    private String street;
    private String zipcode;
}
```

- 하이버네이트에서는 임베디드 타입을 컴포넌트라 한다. 

### 9.2.1 임베디드 타입과 테이블 매핑
- 임베디드 타입은 엔티티의 값일 뿐이다. 
- 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수보다 클래스의 수가 더 많다. 

### 9.2.2 임베디드 타입과 연관관계
- 임베디드 타입은 값 타입을 포함하거나 엔티티를 참조할 수 있다. 

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @Embedded Address address;
    @Embedded PhoneNumber phoneNumber;
}

@Embeddable
public class Address {
    @Column(name = "city")
    private String city;
    private String street;
    @Embedded private Zipcode zipcode;
}

@Embeddable
public class Zipcode {
    String zip;
    String plusFor;
}

@Embeddable
public class PhoneNumber {
    String areaCode;
    String localNumber;
    @ManyToOne PhoeServiceProvider provider;
} 

@Entity
public class PhoneServiceProvider {
    @Id String name;
}
```

### 9.2.3 @AttributeOverride : 속성 재정의
- 매핑정보를 재정의 하려면 @AttributeOverride 를 사용한다.
- 회원 정보에 주소가 하나 더 필요하다면?

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @Embedded Address homeAddress;
    @Embedded Adrress companyAddress;
}

@Entity 
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @Embedded Address homeAddress;
    @Embedded
    @AttributeOverride({
        @AttributeOverride(name = "city", column=@Column(name = "COMPANY_CITY"),
        @AttributeOverride(name = "city", column=@Column(name = "COMPANY_STREET"),
        @AttributeOverride(name = "city", column=@Column(name = "COMPANY_ZIPCODE"))
    }) 
    Adrress companyAddress;
}
```

### 9.2.4 임베디드 타입과 null
- 임베디드 타입이 null일 경우 매핑한 컬럼 값은 모두 null이 된다.

## 9.3 값 타입과 불변 객체
### 9.3.1 값 타입 공유 참조

```java
member1.setHomeAddress(new Address("OldCity"));
Address address = member1.getHomeAddress();

address.setCity("NewCity");
member2.setHomeAddress(address);
```

- 회원 2의 주소만 "NewCity"로 변경되길 기대했지만 회원 1의 주소도 바뀌어 버린다. 
- 뭔가를 수정했는데 예상치 못한 곳에서 문제가 발생하는 것이 부작용(side effect)이라 한다.

### 9.3.2 값 타입 복사

```java
member1.setHomeAddress(new Address("OldCity"));
Address address = member1.getHomeAddress();

Address address2 = address.clone();
address.setCity("NewCity");
member2.setHomeAddress(address);
```

- 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다. 
- 문제는 복사하지 않고 원본의 참조값을 직접 넘기는 것을 막을 방법이 없다는 것
- 객체의 공유 참조는 피할 수 없다. 
- 근본적인 해결책 : 객체의 값을 수정하지 못하게 막는다. 

### 9.3.3 불변 객체
- 객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용을 원천 차단할 수 있다. 따라서 값 타입은 될 수 있으면 불변 객체로 설계 해야한다. 

```java
@Embeddable 
public class Address {
    private String city;

    protected Address();

    public Address(String city) {
        this.city = city;
    }

    public String getCity() {
        return this.city;
    }

    // setter 를 만들지 않음.
}
```

## 9.4 값 타입의 비교
- 동일성 비교: == 사용
- 동등성 비교: equals() 사용

## 9.5 값 타입 컬렉션
- 값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 @ElementCollection, @CollectionTable 어노테이션을 사용한다. 

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    @Embedded
    private Address homeAddress;

    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOODS",
        joinColumns = @JoinColumn(name = "MEMBER_ID"))
    @Column(name = "FOOD_NAME")
    private Set<String> favoriteFoods = new HashSets<String>();

    @ElementCollection
    @CollectionTable(name = "ADDRESS",
        joinColumns = @JoinColumn(name = "MEMBER_ID"))
    private List<Address> addressHistory = new ArrayList<Address>();
}
```

- @CollectionTable 을 생략하면 기본값을 사용해 매핑한다. 기본 값: {엔티티이름}_{컬렉션 속성 이름}

### 9.5.1 값 타입 컬렉션 사용

```java
Member member = new Member();

member.setHomeAddress(new Address("통영", "몽돌해수욕장", "660-123"));

member.setFavoriteFoods().add("짬뽕");
member.setFavoriteFoods().add("탕수육");
member.setFavoriteFoods().add("짜장");

member.getAddressHistory().add(new Address("서울", "강남", "123-123"));
member.getAddressHistory().add(new Address("서울", "강북", "000-000"));

em.persist(member);
```

- member: INSERT SQL 1번
- member.homeAddress : 컬렉션이 아닌 임베디드 값 타입이므로 회원테이블을 저장하는 SQL 에 포함
- member.favoriteFoods : INSERT SQL 3번
- member.addressHistory: INSERT SQL 2번

- 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거(ORPHAN REMOVE) 기능을 필수로 가진다고 볼 수 있다. 

```java
Member member = em.find(Member.class, 1L);

member.setHomeAddress(new Address("새로운 도시", "신도시1", "123456"));

Set<String> favoriteFoods = member.getFavoriteFoods();
favoriteFoods.remove("탕수육");
favoriteFoods.add("치킨");

List<Address> addressHistory = member.getAddressHistory();
addressHistory.remove(new Address("서울", "기본 주소", "123-123"));
addressHistory.add(new Address("새로운 도시", "새로운 주소", "123-456"));
```

1. 임베디드 값 타입 수정 : MEMBER 엔티티를 수정하는 것과 같다
2. 기본값 타입 컬렉션 수정: 탕수육을 제거하고 치킨을 추가해야한다. 
3. 임베디드 값 타입 컬렉션 수정: 값 타입은 불변해야한다. 

### 9.5.2 값 타입 컬렉션의 제약사항
- 식별자가 100번인 회원이 관리하는 주소값 타입 컬렉션을 변경하면 100번과 관련된 모든 주소 데이터를 삭제하고 현재 값 타입 컬렉션에 있는 값을 다시 저장한다. 
- 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다. 


## 핵심 요약
- 값 타입은 불변 객체로 만들어라
- equals/hashCode는 반드시 구현
- 값 타입 컬렉션은 "작고 거의 안 바뀌는 데이터"에만 사용
- 대용량이면 엔티티로 분리
- 값 타입은 도메인 모델을 풍부하게 만들기 위한 도구