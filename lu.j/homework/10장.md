# 10장 과제 – 객체지향 쿼리 언어

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 묵시적 조인의 위험성

아래 JPQL에서 실제로 나가는 SQL은 무엇인가요?

```
select m.team.name from Member m
```

- 왜 이런 묵시적 조인이 위험할까요?
- 본인이라면 실무에서 어떻게 작성하실 건가요?


답) 
- 일단 쿼리만 봐서는 조인이 눈에 띄지 않는데 실제 SQL 은 inner join 으로 만들어서 나가게 됩니다. 
- 묵시적 조인은 무조건 inner join 을 쓰게 되기 때문에 실무에서는 의도와 다르게 동작할 수 있습니다.
- 명시적으로 조인을 걸어주는 형태로 사용하게 될 것 같습니다. 

---

### Q2. fetch 조인과 값 타입

- 임베디드 타입(`@Embedded`)으로 설계된 필드는 fetch 조인이 필요한가요?
- 엔티티 연관관계와 비교하여, 조회 시점의 동작 차이를 설명해주세요.

답)
- @Embedded 는 같은 테이블의 컬럼 묶음이라서 fetch join 을 할 수 없습니다. 
- 엔티티 연관관계는 별도 테이블이므로 LAZY 로딩이 가능하고 접근 시마다 글로벌하게 EAGER 로딩을 하지 않고 fetch join 으로 조회 시점에 함께 로딩하도록 제어하는 것이 효과적입니다. 

---

### Q3. 벌크 연산과 영속성 컨텍스트

- 아래 코드의 문제점은 무엇인가요?
- 어떻게 해결하실 건가요?

```kotlin
val member = em.find(Member::class.java, 1L)
// member.age == 20

em.createQuery("update Member m set m.age = m.age + 1")
    .executeUpdate()

println(member.age)
```

답)
- 벌크 연산의 경우 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 문제가 있습니다.
- 해결 방안은 아래와 같이 3가지 가 있습니다. 
    - em.refresh()
    - 벌크 연산 먼저 실행
    - 벌크 연산 수행 후 영속성 컨텍스트 초기화

---

## (Optional) 자유 토론 주제
10장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.

- 저는 QueryDSL 이 좀더 좋을 것 같긴 한데.. 다들 어떤 걸로 쓰는게 좋을지 이야기 해보면 좋을 것 같아요. 너무 복잡한 쿼리의 경우엔 지금처럼 NativeQuery 를 섞어 쓰는 것이 맞을 것 같긴 합니다. 
- 마이바티스와 JPA 를 섞어 쓰는 경우에도 문제 없을 것 같아서, 써야할 곳에 도입해보면 좋지 않을까 싶네요. 