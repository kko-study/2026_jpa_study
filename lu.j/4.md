# 4장. 엔티티 매핑

- 객체와 테이블 매핑 : @Entity, @Table
- 기본 키 매핑 : @Id
- 필드와 컬럼 매핑 : @Column
- 연관관계 매핑 : @ManyToOne, @JoinColumn

## 4.1 @Entity

- @Entity 어노테이션은 JPA 를 사용해서 테이블과 매핑할 클래스는 무조건 붙여야한다.
- @Entity 사용 시 주의점
  - 기본 생성자는 필수
  - final 클래스, enum, interface, inner 클래스는 사용 불가
  - 저장할 필드에 final 붙이면 안됨

## 4.2 @Table

- 엔티티와 매핑할 테이블을 지정
- 속성
  - name : 매핑할 테이블 이름
  - catalog : catalog 기능이 있을 경우 매핑
  - schema : schema 기능이 있을 경우 매핑
  - uniqueConstraints : DDL 생성 시 유니크 제약조건을 만든다. 스키마 자동 생성 기능을 이용할 때만 사용됨

## 4.3 다양한 매핑 사용

```java
@Entity
@Table(name = "MEMBER")
public class Member {
  @Id
  @Column(name = "ID")
  private String id;

  @Column(name = "NAME")
  private String username;

  private Integer age;

  // 추가된 필드
  @Enumerated(EnumType.STRING)
  private RoleType roleType;

  @Temporal(TemporalType.TIMESTAMP)
  private Date createdDate;

  @Temporal(TemporalType.TIMESTAMP)
  private Date lastModifiedDate;

  @Lob
  private String description;
}
```

- enum 을 사용하려면 @Enumerated 를 사용해야한다.
- 날짜 타입은 @Temporal 을 사용해서 매핑한다.
- description 의 경우 길이 제한이 없으므로 CLOB 타입으로 저장한다. @Lob 은 CLOB, BLOB 타입을 매핑할 수 있다.

## 4.4 데이터베이스 스키마 자동 생성

- hibernate.hdb2ddl.auto = create 이 속성을 사용하면 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성
- _(개인적인 의견)_

  - Spring Data JPA 의 경우 `spring.jpa.hibernate.ddl-auto=create` 옵션을 사용
  - 또는 `spring.sql.init.mode: always` 를 이용해 schema.sql, data.sql 을 실행하게 할 수도 있다.

### 이름 매핑 전략 변경하기

- Spring boot 2.x 이상 부터는 따로 설정 안해도 언더스코어로 나오게 되어 있다.

## 4.5 DDL 생성 기능

- DDL 에 제약조건을 추가해보자

```java
@Entity
@Table(name="MEMBER")
public class Member {
  @Id
  @Column(name = "ID")
  private String id;

  @Column(name = "NAME", nullable = false, length = 10)
  private String username;
}
```

```SQL
create table MEMBER {
  ID varchar(255) not null
  NAME varchar(10) not null
  ...
}
```

- 유니크 제약조건 uniqueConstraints 도 써보자.

```java
@Entity(name = "Member")
@Table(name = "MEMBER", unqueConstraints = {@UniqueConstraint(
  name = "NAME_AGE_UNIQUE",
  columnNames = {"NAME", "AGE"}
)})
```

```SQL
ALTER TABLE MEMBER
  ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE (NAME, AGE)
```

- DDL 을 생성할 떄만 사용되고 실제 JPA 실행 로직에는 영향을 주지 않는다.

## 4.6 기본 키 매핑

- @Id 어노테이션을 이용해 기본 키 매핑을 했다. AUTO_INCREMENT 같은 기능을 사용해 기본키로 쓰려면 어떻게 해야할까?
- JPA 가 제공하는 데이터베이스 기본 키 생성 전략

  - 직접 할당 : 기본 키를 애플리케이션에서 직접 할당
  - 자동 생성 : 대리 키 사용 방식
    - IDENTITY: 기본키 생성을 DB에 위임
    - SEQUENCE: DB의 시퀀스를 사용해서 기본키 할당
    - TABLE: 키 생성 테이블 사용

- 직접 할당 시 AUTO_INCREMENT 를 쓰려면 @GeneratedValue 를 쓰면 된다.
- 저자가 이야기 한 hibernate.id.new_generator_mappings 는 기본값이 true로 바뀌었다고 한다.

### 4.6.1 기본 키 직접 할당 전략

- @Id 로 매핑

### 4.6.2 IDENTITY 전략

- 키 생성을 데이터베이스에 위임
- AUTO_INCREMENT 로 테이블을 설정한 뒤에 id 에 null을 넣어주면 DB가 값을 채워준다.

```java
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private long id;
```

- 위 설정을 해줘야한다.
- 이 전략은 키 생성이 DB에서 이루어지기 때문에 Transaction 을 지원하는 쓰기 지연이 동작하지 않는다.

### 4.6.3 SEQUENCE 전략

- 시퀀스 매핑

```java
@Entity
@SequenceGenerator(
  name = "BOARD_SEQ_GENERATOR",
  sequenceName = "BOARD_SEQ",
  initialValue = 1, allocationSize = 1
)
public class Board {
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator="BOARD_SEQ_GENERATOR")
  private long id;
}
```

- 실제 DB의 시퀀스와 매핑한다.
- 시퀀스는 IDENTITY 와 코드는 같지만 내부 동작은 다르다.
- 시퀀스의 경우 em.persist() 를 호출할 때 데이터베이스의 식별자를 조회한다. 조회한 식별자를 엔티티에 할당 후에 영속성 컨텍스트에 저장한다.

#### @SequenceGenerator

- name: 식별자 생성기 이름
- sequenceName: DB에 등록된 시퀀스 이름
- initialValue: DDL 생성 시에만 사용
- allocationSize: 시퀀스 한번 호출에 증가하는 수 / 기본값 50

  - 기본값이 50 이므로 DB에서 1씩 증가하게 되어 있다면 변경이 필요함

- _(개인적인 의견)_
  - 어떤걸 취하는 것이 좋을까?
    - DB에 따라 다를 것 같음. MYSQL 의 경우 auto_increment 로 인해 identity 를 사용할 것이고,
    - Postgresql 은 시퀀스 사용이 되기에 SEQUENCE 를 쓸 수 있을것.
    - sequence 는 new_generator_mappings 를 true 로 설정해야 최적화가 되기 때문에 Postgresql 을 쓰면 Sequence 를 쓰는게 좋지 않을까? -> 성능 상 유리해보임

### 4.6.4 TABLE 전략

- 키 생성 전용 테이블을 생성한 뒤에 DB 시퀀스를 흉내내는 전략

### 4.6.5 AUTO 전략
- 데이터베이스의 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중에 하나를 자동 선택

```java
@Entity
public class Board {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;
}
```

- 기본값이 AUTO 라서 쓰지 않아도 자동으로 설정된다. 

### 4.6.6 기본 키 매핑 정리

- 직접 할당 : em.persist() 를 호출하기 전에 직접 식별자 값을 할당해야함
- SEQUENCE : 데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장
- TABLE : 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장
- IDENTITY : 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장

#### 권장하는 식별자 선택 전략
- 데이터베이스의 기본키는 3가지 조건을 모두 만족해야한다.
  - null 값은 허용하지 않음
  - 유일해야함
  - 변해선 안됨

- 테이블의 기본키 전략은 크게 2가지
  - 자연키
    - 비즈니스에 의미가 있는 키
    - e.g. 주민등록번호, 이메일, 전화번호
  - 대리키
    - 임의로 만들어진 키
    - e.g. auto_increment, sequence 등

- 자연키 보다는 대리키 권장
- 비즈니스 환경은 언젠가는 변함

## 4.7 필드와 컬럼 매핑 : 레퍼런스
- @Column : 컬럼 매핑
- @Enumerated : 자바 enum 매핑
- @Temporal : 날짜 타입 매핑
- @Lob : BLOB, CLOB 타입 매핑
- @Transient : 특정 필드를 데이터베이스에 매핑하지 않음
- @Access : JPA가 엔티티에 접근하는 방식 지정

### 4.7.1 @Column
- 객체 필드를 테이블 컬럼에 매핑
- name. nullable 이 가장 많이 사용됨

- nullable (DDL 생성 가능)
```java
@Column(nullable = false)
private String data;

// 생성된 DDL
data varchar(255) not null
```

- unique (DDL 생성 가능)
```java
@Column(unique = true)
private String username;

// 생성된 DDL
alter table Tablename
  add constraint UK_Xxx unique (username)
```

- columnDefinition (DDL 생성 가능)
```java
@Column(columnDefinition = "varchar(100) default 'EMPTY'")
private String data;

// 생성된 DDL
data varchar(100) default 'EMPTY'
```

- length (DDL 생성 가능)
```java
@Column(length = 400)
private String data;

// 생성된 DDL
data varchar(400)
```

- precision, scale (DDL 생성 가능)
```java
@Column(precision = 10, scale = 2)
private BigDecimal cal;

// 생성된 DDL
cal numeric(10, 2)  // h2, Postgresql
cal number(10,2)    // oracle
cal decimal (10,2)  // mysql
```

#### @Column 생략
- 자바의 기본 타입일 때는 nullable 속성에 예외가 있다. 
```java
int data1;      // @Column 생략
data1 integer not null

Integer data2;  // @Column 생략
data integer

@Column
int data1;      // @Column 사용
data integer
```

- int data1 같은 기본 타입을 생성 시엔 not null 제약조건을 추가하는 것이 안전하다. 
- 그러나 @Column 은 nullable = true 가 기본값이라 not null 제약조건을 설정하지 않는다. 기본 타입에 @Column 을 사용할 경우 nullable = false 를 이용하는게 좋다. 

### 4.7.2 @Enumerated 
- enum 타입을 매핑할 때 사용

#### @Enumerated 사용 예

```java
enum RoleType {
  ADMIN, USER
}

@Enumerated(EnumType.STRING)
private RoleType roleType;

member.setRoleType(RoleType.ADMIN);   // DB엔 대문자 ADMIN 이 저장됨
```

- EnumType.ORDINAL 은 enum 에 정의된 순서대로 ADMIN - 0, USER - 1 이 저장된다. 
- EnumType.STRING 은 enum 에 정의된 그대로 문자로 저장된다. 

#### ORDIANL 사용 시 주의점
- ADMIN, USER 순서를 쓰다가 중간에 NEW 라고 추가할 경우 원래 ADMIN - 0, USER - 1로 저장되다가 NEW 가 중간에 들어와서 ADMIN - 0, NEW - 1, USER - 2로 바뀌어버리기 때문에 STRING을 쓰는 것을 추천

### 4.7.3 @Temporal
- 날짜 타입을 매핑할 때 사용

```java
@Temporal(TemporalType.DATE)
private Date date;

@Temporal(TemporalType.TIME)
private Date time;

@Temporal(TemporalType.TIMESTAMP)
private Date timestamp;

date date,
time time,
timestamp timestamp
```

*(개인적인 의견)*
#### LocalDateTime, LocalDate, Instant 는 어떻게 매핑되지?
- JPA 2.2 이상 부터는 그냥 매핑 가능함
- @Temporal 은 Date, Calendar 전용임

### 4.7.3 @Lob
- DB의 BLOB, CLOB 타입과 매핑

#### @Lob 사용 예

```java
@Lob
private String lobString;

@Lob
private byte[] lobByte;

// oracle
lobString clob
lobByte blob

// MySQL
lobString logtext
lobByte longblob

// Postgresql
lobString text
lobByte oid
```

### 4.7.4 @Transient
- 매핑하지 않기 위해 사용하는 어노테이션

```java
@Transient
private Integer temp;
```

### 4.7.6 @Access
- 엔티티 데이터에 접근하는 방식 설정
- 필드 접근
  - AccessType.FIELD 로 지정
  - private 이어도 접근이 가능해짐
- 프로퍼티 접근
  - AccessType.PROPERTY로 지정
  - Getter 접근자를 사용해 접근

```java
@Entity
@Access(AccessType.FIELD)
public class Member {
  @Id
  private String id;

  private String data1;
  private String data2;
}
```

- 프로퍼티 접근 코드

```java
@Entity
@Access(AccessType.PROPERTY)
public class Member {
  private String id;

  private String data1;
  private String data2;

  @Id
  public String getId() {
    return id;
  }

  @Column
  public String getData1() {
    return data1;
  }

  public String getData2() {
    return data2;
  }
}
```

- 함께 사용시 fullName 은 firstName + lastName 으로 DB 에 저장된다. 

```java
@Entity
public class Member {
  @Id
  private String id;

  @Transient
  private String firstName;

  @Transient
  private String lastName;

  @Access(AccessType.PROPERTY)
  public String getFullName() {
    return firstName + lastName;
  }
}
```