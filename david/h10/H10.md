# 10장 과제 – 객체지향 쿼리 언어

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 묵시적 조인의 위험성

아래 JPQL에서 실제로 나가는 SQL은 무엇인가요?

```
select m.team.name from Member m
```
select t.name
from Member m
inner join team t on m.team_id = t.id

- 왜 이런 묵시적 조인이 위험할까요?
조인이 일어나는 상황을 한 눈에 파악이 어려움
성능 향상을 위해 쿼리 분석 시 파악이 어려우므로 명시적 조인을 사용하는 것이 좋음

- 본인이라면 실무에서 어떻게 작성하실 건가요?
select t.name  
from Member m  
join m.team t

---

### Q2. fetch 조인과 값 타입

- 임베디드 타입(`@Embedded`)으로 설계된 필드는 fetch 조인이 필요한가요?
필요하지 않음
임베디드는 별도 테이블로 저장되지 않으므로 항상 함께 조회

- 엔티티 연관관계와 비교하여, 조회 시점의 동작 차이를 설명해주세요.
fetch 조인 미사용
연관관계를 고려하지 않고 SELECT 지정된 엔티티만 조회
lazy 경우 조회되지 않음 
eager인 경우 직후 연관관계까지 조회하므로 쿼리 2회 실행

fetch 조인 사용
fetch join 지정된 테이블 같이 조회하여 즉시 로딩처럼 적용
쿼리 1회 실행

---

### Q3. 벌크 연산과 영속성 컨텍스트

- 아래 코드의 문제점은 무엇인가요?
벌크 연산이 영속성 컨텍스트 무시하므로 이미 member의 age 업데이트 되었는데 영속성 컨텍스트는 여전히 20으로 조회됨

- 어떻게 해결하실 건가요?
벌크 연산을 가장 먼저 수행
em.refresh
영속성 컨텍스트 초기화

```kotlin
val member = em.find(Member::class.java, 1L)
// member.age == 20

em.createQuery("update Member m set m.age = m.age + 1")
    .executeUpdate()

println(member.age)
```

---
