# 9장 과제 – 값 타입

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 값 타입 컬렉션 vs 일대다 엔티티

주소 이력(`AddressHistory`)을 관리해야 하는 상황입니다.

A안: `@ElementCollection`으로 값 타입 컬렉션 사용<br>
B안: AddressHistory를 별도 엔티티로 만들고 `@OneToMany` 사용

- 각 방식을 선택했을 때, **수정/삭제 시 발생하는 SQL**은 어떻게 달라지나요?
- 실무에서 어떤 기준으로 선택하실 건가요?


### A1.
- 수정/삭제 시 SQL 차이
  - A안: 값 타입은 식별자가 없어 관리가 불가능함, 따라서 변경 발생 시 해당 회원의 addressHistory 값을 전부 DELETE 후 전부 다시 INSERT 함
  - B안: 엔티티 자체 PK로 개별 row를 특정할 수 있으므로, 해당 row만 UPDATE/DELETE 함

- 실무 선택 기준
  - B안 선택. 데이터가 많아질수록 전체 삭제+재삽입은 성능 이슈.
  - 값 타입 컬렉션은 정말 단순하고 변경이 거의 없는 경우에만 사용

- 보완 설명
  - CASCADE.ALL + orphanRemoval = true를 설정하면 값 타입 컬렉션처럼 라이프사이클 관리가 가능하여 B안의 코드 복잡도 단점도 완화됨
  - @ElementCollection은 값 타입 컬렉션이기 때문에 식별자 없음. (PK가 (MEMBER_ID + 모든 값 컬럼)의 복합키로 구성됨)


### Q2. 임베디드 타입과 불변 객체

임베디드 타입(`@Embeddable`)은 여러 엔티티에서 공유하면 사이드 이펙트가 발생할 수 있다고 합니다.
이를 방지하기 위해 "불변 객체로 만들어야 한다"고 하는데,

- 불변 객체로 만들면 값을 변경하고 싶을 때는 어떻게 해야 할까요?
- 본인이 실무에서 Address 같은 임베디드 타입을 설계한다면 어떻게 하실건가요?

### A2.
- 불변 객체 => setter 제거. 코틀린에서는 val 프로퍼티로 구현
- 값을 변경하고 싶을 때는 새 객체를 생성하여 통째로 교체 (data 클래스의 copy() 활용)
- 실무 설계: data class + val 조합으로 불변 + 동등성 비교 + 편리한 교체를 모두 확보하고, JPA를 위한 protected 기본 생성자를 추가
- 참고 : 지난주 과제 하면서 공부했던 것 중에 엔티티에는 data class는 사용하지 않는게 좋음. 임베디드(값) 타입이기 때문에 사용. 

## (Optional) 자유 토론 주제
9장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.