# 10장 과제 – 객체지향 쿼리 언어

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 묵시적 조인의 위험성

아래 JPQL에서 실제로 나가는 SQL은 무엇인가요?

```
select m.team.name from Member m
```

실제 SQL
```
select t.name
from member m inner join team t on m.team_id = t.id
```

- 왜 이런 묵시적 조인이 위험할까요?
  - 묵시적 조인은 inner join이기 때문에 null 연관관계 row가 누락될 수 있고, JPQL을 보고 조인, 쿼리 성능 등을 예측하기 어렵다.
- 본인이라면 실무에서 어떻게 작성하실 건가요?
  - 의도에 따라 join, left join을 명시적으로 작성한다.
```
select t.name
from Member m join m.team t
```
---

### Q2. fetch 조인과 값 타입

- 임베디드 타입(`@Embedded`)으로 설계된 필드는 fetch 조인이 필요한가요?
  - 같은 엔티티 테이블에 저장되어 엔티티를 조회할 때 함께 조회되므로 fetch 조인이 필요 없다.
- 엔티티 연관관계와 비교하여, 조회 시점의 동작 차이를 설명해주세요.
  - 임베디드 타입은 엔티티를 조회할 때 함께 조회된다. (프록시, 지연로딩 없음)
  - 연관 엔티티는 LAZY로 설정되어 있으면 실제로 사용할 때 조회된다. fetch join으로 지연로딩 없이 조회할 수도 있다. 

---

### Q3. 벌크 연산과 영속성 컨텍스트

- 아래 코드의 문제점은 무엇인가요?
  - member가 이미 영속성 컨텍스트로 관리되고 있는데 벌크 연산으로 DB에 직접 update 쿼리를 해서 age를 21로 업데이트 된다. 영속성 컨텍스트의 member 객체는 여전히 age가 20이고, DB에는 age가 21이므로 영속성 컨텍스트와 DB의 데이터가 달라진다. 
- 어떻게 해결하실 건가요?
  - 영속성 컨텍스트 리프레시 (`em.refresh(member)`)
  - 벌크 연산 수행 후 member 조회해서 사용
  - 벌크 연산 수행 후 영속성 컨텍스트 초기화

```kotlin
val member = em.find(Member::class.java, 1L)
// member.age == 20

em.createQuery("update Member m set m.age = m.age + 1")
    .executeUpdate()

println(member.age)
```

---

## (Optional) 자유 토론 주제
10장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.