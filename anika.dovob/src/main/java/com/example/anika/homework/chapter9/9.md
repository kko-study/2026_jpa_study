# 9장 과제 – 값 타입

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 값 타입 컬렉션 vs 일대다 엔티티

주소 이력(`AddressHistory`)을 관리해야 하는 상황입니다.

A안: `@ElementCollection`으로 값 타입 컬렉션 사용<br>
B안: AddressHistory를 별도 엔티티로 만들고 `@OneToMany` 사용

- 각 방식을 선택했을 때, **수정/삭제 시 발생하는 SQL**은 어떻게 달라지나요?
  - A안: 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고, 현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스에 다시 저장한다. 
  - B안: PK 사용해서 row 단위로 수정/삭제가 가능하다. 
- 실무에서 어떤 기준으로 선택하실 건가요?
  - 부분 수정이 아닌 전체 수정만 발생하는 경우 또는 데이터가 작아서 전체 delete/insert가 괜찮은 경우에는 `@ElementCollection`을 고려한다.  
  - 그 외에는 별도 엔티티를 만들고 `@OneToMany`를 사용하는 방식을 사용한다. 

---

### Q2. 임베디드 타입과 불변 객체

임베디드 타입(`@Embeddable`)은 여러 엔티티에서 공유하면 사이드 이펙트가 발생할 수 있다고 합니다.
이를 방지하기 위해 "불변 객체로 만들어야 한다"고 하는데,

- 불변 객체로 만들면 값을 변경하고 싶을 때는 어떻게 해야 할까요?
  - 값 복사로 새로운 인스턴스를 만들어서 사용한다. 
- 본인이 실무에서 Address 같은 임베디드 타입을 설계한다면 어떻게 하실건가요?
  - 코틀린이라면 data class + copy를 활용해서 불변 객체로 설계한다.
  - 자바라면 setter를 제거해서 외부에서 변경이 불가능하도록 설계한다.

---


## (Optional) 자유 토론 주제
9장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.

### 코틀린 기본 값 타입
* **문자열/문자**
    * `String`, `Char`(보통은 `String(1)`로 매핑)

* **숫자**
    * `Byte`, `Short`, `Int`, `Long`
    * `Float`, `Double`
    * `BigDecimal`, `BigInteger`

* **불리언**
    * `Boolean`

* **바이너리**
    * `ByteArray` (`BLOB`, `VARBINARY` 등)

* **날짜/시간**
    * (구 JPA) `java.util.Date`, `java.util.Calendar` + `@Temporal`
    * (Hibernate/JPA 2.2+ 실무) `java.time.LocalDate`, `LocalDateTime`, `Instant`, `OffsetDateTime` 등

* **열거형**
    * `enum class ...` + `@Enumerated(EnumType.STRING)` 권장

* **기타(프로바이더 의존)**
    * `UUID` (Hibernate는 보통 바로 지원)
    * `Serializable`(권장되진 않음)

