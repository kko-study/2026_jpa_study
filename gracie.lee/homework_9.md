# 9장 과제 – 값 타입

---

### Q1. 값 타입 컬렉션 vs 일대다 엔티티

주소 이력(`AddressHistory`)을 관리해야 하는 상황입니다.

A안: `@ElementCollection`으로 값 타입 컬렉션 사용<br>
B안: AddressHistory를 별도 엔티티로 만들고 `@OneToMany` 사용

- 각 방식을 선택했을 때, **수정/삭제 시 발생하는 SQL**은 어떻게 달라지나요?
- 실무에서 어떤 기준으로 선택하실 건가요?

#### 답변

- **A안 (`@ElementCollection`)**: 값 타입은 ID가 없어서 개별 행을 특정할 수 없음. 하나만 바꿔도 해당 멤버의 주소 데이터를 전부 DELETE 후 나머지를 다시 INSERT함.
- **B안 (`@OneToMany`)**: 엔티티라 ID가 있으므로 `DELETE FROM address_history WHERE id = ?` 하나로 끝남.

변경이 거의 없는 단순한 값(태그, enum 등)이면 `@ElementCollection`도 괜찮지만, 주소 이력처럼 데이터가 쌓이고 수정/삭제가 일어나는 경우엔 별도 엔티티 + `@OneToMany`를 쓸 것 같음.

---

### Q2. 임베디드 타입과 불변 객체

임베디드 타입(`@Embeddable`)은 여러 엔티티에서 공유하면 사이드 이펙트가 발생할 수 있다고 합니다.
이를 방지하기 위해 "불변 객체로 만들어야 한다"고 하는데,

- 불변 객체로 만들면 값을 변경하고 싶을 때는 어떻게 해야 할까요?
- 본인이 실무에서 Address 같은 임베디드 타입을 설계한다면 어떻게 하실건가요?

#### 답변

기존 객체를 수정하지 않고, 새 객체를 만들어서 통째로 교체한다.

```java
member.setAddress(new Address("분당", "판교로", "165"));
```

setter를 제공하지 않고 생성자로만 값을 세팅하게 만든다. 값 변경이 필요하면 새 인스턴스를 만들어 교체하는 방식으로 사용할 것 같다.
