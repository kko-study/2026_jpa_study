# 10장 과제 – 객체지향 쿼리 언어

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 묵시적 조인의 위험성

아래 JPQL에서 실제로 나가는 SQL은 무엇인가요?

```
select m.team.name from Member m
```

실행된 SQL
```
select m.* 
from Member m 
inner join Team t on m.team_id = t.id
```

- 왜 이런 묵시적 조인이 위험할까요?
  - 한눈에 파악하기 어렵다.
  - 우리가 의도하지 않았지만 묵시적으로 내부 조인이 발생하고, 이는 곧 성능 저하로 이어지게 될 수 있다.
- 본인이라면 실무에서 어떻게 작성하실 건가요?
  - 차라리 그럴바에 명시적으로 조인을 해서 알 수 있도록 한다.

---

### Q2. fetch 조인과 값 타입

- 임베디드 타입(`@Embedded`)으로 설계된 필드는 fetch 조인이 필요한가요?
  - 엔티티를 위해 사용되는 조인이고, 임베디드 타입은 엔티티와 같이 저장되기 때문에 별도의 조인이 필요하지 않다.
- 엔티티 연관관계와 비교하여, 조회 시점의 동작 차이를 설명해주세요.
  - 엔티티 fetch 조인을 하면 바로 엔티티들을 조회해서 가져올 수 있다.
  - 이것을 물어보는 것인지 모르겠다.

---

### Q3. 벌크 연산과 영속성 컨텍스트

- 아래 코드의 문제점은 무엇인가요?
  - 벌크 연산 이후 영속성 컨텍스트에 있는 엔티티의 상태가 변경되지 않았다.
  - 왜냐하면 벌크 연산은 바로 DB에 실행되기 때문
- 어떻게 해결하실 건가요?
  - 조회하기 전에 벌크 연산을 진행하던지
  - 벌크 연산 이후 refresh
  - 벌크 연산 이후 영속성 컨텍스트를 초기화

```kotlin
val member = em.find(Member::class.java, 1L)
// member.age == 20

em.createQuery("update Member m set m.age = m.age + 1")
    .executeUpdate()

println(member.age)
```

---

## (Optional) 자유 토론 주제
10장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.