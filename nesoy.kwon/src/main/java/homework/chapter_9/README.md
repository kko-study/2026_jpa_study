# 9장 과제 – 값 타입

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 값 타입 컬렉션 vs 일대다 엔티티

주소 이력(`AddressHistory`)을 관리해야 하는 상황입니다.

A안: `@ElementCollection`으로 값 타입 컬렉션 사용
B안: AddressHistory를 별도 엔티티로 만들고 `@OneToMany` 사용

- 각 방식을 선택했을 때, **수정/삭제 시 발생하는 SQL**은 어떻게 달라지나요?
- 실무에서 어떤 기준으로 선택하실 건가요?

### 답변
#### A안
- @ElementCollection을 사용하면, Address 엔티티에 종속되는 구조
  - 엔티티 테이블
    - ID, CITY, STREET, ZIPCODE
  - 컬렉션 테이블(Address)
    - 엔티티 ID, CITY, STREET, ZIPCODE
    - 자체 PK가 없다.
- 위의 구조적 한계 때문에 엔티티를 읽고 컬렉션 테이블에 변경이 발생하면 one-shot delete가 발생한다.
  - 값이 몇개가 있던 모두 delete를 진행하고 다시 변경사항을 insert한다.
```
  DELETE FROM ADDRESS WHERE MEMBER_ID = ?   -- 전체 삭제
  INSERT INTO ADDRESS (...) VALUES (?, ?, ?, ?)  -- 재삽입
  INSERT INTO ADDRESS (...) VALUES (?, ?, ?, ?)  -- 재삽입
```

### B안
- A안의 구조적 한계를 개선하기 위해 Addresshistory를 별도의 엔티티로 만들어서, 여러번 쿼리를 줄일 수 있다.
  - AddressHistory의 PK를 기준으로 수정 / 삭제를 진행한다.

### 실무 측면
- B안이 왠만해서는 괜찮을거 같은데...?
- 잘못 사용하면, 쿼리 열심히 날리는 문제가 발생할듯..

---

### Q2. 임베디드 타입과 불변 객체

임베디드 타입(`@Embeddable`)은 여러 엔티티에서 공유하면 사이드 이펙트가 발생할 수 있다고 합니다.
이를 방지하기 위해 "불변 객체로 만들어야 한다"고 하는데,

- 불변 객체로 만들면 값을 변경하고 싶을 때는 어떻게 해야 할까요?
- 본인이 실무에서 Address 같은 임베디드 타입을 설계한다면 어떻게 하실건가요?

---

## 불변 객체로 만들면 값을 변경하고 싶을 때
- 새로 만들어서 대체하자.

## 본인이 실무에서 Address 같은 임베디드 타입을 설계한다면?
- 변경자(setter)를 다 제거하고, 새로 생성하는 구조를 강제할거 같다.


## (Optional) 자유 토론 주제
9장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.