# 10장 과제 – 객체지향 쿼리 언어

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 묵시적 조인의 위험성

아래 JPQL에서 실제로 나가는 SQL은 무엇인가요?

```
select m.team.name from Member m
```

- 왜 이런 묵시적 조인이 위험할까요?
  - 말그대로 명시되어있지 않기 떄문에 실제 쿼리 발생시 내부 조인이 일어난다는 것을 인지하기 어렵다.
  > **피드백**: 핵심을 잘 짚었습니다. 여기에 추가로, 묵시적 조인은 항상 **INNER JOIN**으로 발생하기 때문에 `team`이 null인 Member는 결과에서 누락된다는 점도 위험 요소입니다. 또한 경로 표현식이 깊어질수록(`m.team.organization.name` 등) 조인이 연쇄적으로 발생하는데, JPQL만 보고는 몇 개의 조인이 나가는지 파악하기 어렵다는 점도 언급하면 좋습니다.

- 본인이라면 실무에서 어떻게 작성하실 건가요?
  - 묵시적 조인을 사용하지 않고 명시적 조인을 통해 명확하게 jpql을 작성할 것 같다.
  > **피드백**: 좋습니다. 실제로 명시적 조인을 쓰면 `select t.name from Member m join m.team t`처럼 작성하게 되는데, 이렇게 하면 INNER/LEFT 조인 선택도 개발자가 직접 제어할 수 있고, 쿼리 튜닝 시에도 조인 구조를 한눈에 파악할 수 있습니다.


---

### Q2. fetch 조인과 값 타입

- 임베디드 타입(`@Embedded`)으로 설계된 필드는 fetch 조인이 필요한가요?
  - 임베디드 타입으로 설계된 필드는 해당 엔티티의 컬럼으로 직접 포함되기 떄문에 조인 자체가 필요없을 것 같다.
  > **피드백**: 정확합니다. 임베디드 타입은 엔티티 테이블에 컬럼으로 함께 저장되므로, 엔티티 조회 시 항상 같은 SELECT에 포함됩니다. 지연 로딩이나 N+1 문제가 구조적으로 발생하지 않습니다.

- 엔티티 연관관계와 비교하여, 조회 시점의 동작 차이를 설명해주세요.
  - 다대일 일때는 결과가 늘어나는 경우는 없고, 그저 조회하는 컬럼자체만 추가될 뿐이다. 그러나 일대다 관계일때는 일(1)에 해당하는 다(N)가 몇개인지 쿼리를 직접 해봐야 알고, 얼마나 늘어날지는 데이터에 따라 다를 것 같다.
  > **피드백**: 다대일/일대다에 따른 결과 행 수 차이를 잘 설명했습니다. 다만 질문의 핵심은 **"임베디드 타입 vs 엔티티 연관관계"의 조회 시점 동작 차이**입니다. 임베디드 타입은 별도 테이블이 없으므로 항상 즉시 로딩(같은 row)이지만, 엔티티 연관관계는 별도 테이블에 있어 **기본적으로 지연 로딩(프록시)**이 적용되고, 실제 접근 시 추가 SELECT가 발생합니다. 이 N+1 문제를 해결하기 위해 fetch 조인이 필요한 것이죠. 이 대비를 명시하면 더 완성도 높은 답변이 됩니다.


---

### Q3. 벌크 연산과 영속성 컨텍스트

- 아래 코드의 문제점은 무엇인가요?
  - 벌크연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다. 해당 코드의 마지막 println에서 member.age는 21로 업데이트 된 값이 아닌 영속성컨텍스트의 객체 그대로 20일 찍힐것으로 보인다. 그래서 DB와 영속성컨텍스트간 데이터가 맞지 않게 된다.
  > **피드백**: 정확합니다. "영속성 컨텍스트를 무시하고 DB에 직접 쿼리"라는 핵심을 정확히 짚었고, 결과값(20)과 DB 불일치 문제까지 잘 설명했습니다.

- 어떻게 해결하실 건가요?
  - 벌크연산을 먼저 수행하거나, 벌크연산을 수행한 직후 영속성 컨텍스트를 초기화하는 방식을 할 것이다.
  > **피드백**: 두 가지 해결책 모두 맞습니다. 실무에서는 **벌크 연산 후 `em.clear()`**(또는 Spring Data JPA에서 `@Modifying(clearAutomatically = true)`)가 가장 범용적으로 쓰입니다. "벌크 연산을 먼저 수행"하는 방식은 이미 영속성 컨텍스트에 올라온 엔티티가 없을 때만 유효하므로, 항상 적용 가능한 `em.clear()` 방식을 기본으로 가져가는 것이 안전합니다.


```kotlin
val member = em.find(Member::class.java, 1L)
// member.age == 20

em.createQuery("update Member m set m.age = m.age + 1")
    .executeUpdate()

println(member.age)
```

---

## (Optional) 자유 토론 주제
9장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작s성해주세요.
