# 9장 과제 – 값 타입

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 값 타입 컬렉션 vs 일대다 엔티티

주소 이력(`AddressHistory`)을 관리해야 하는 상황입니다.

A안: `@ElementCollection`으로 값 타입 컬렉션 사용<br>
B안: AddressHistory를 별도 엔티티로 만들고 `@OneToMany` 사용

- 각 방식을 선택했을 때, **수정/삭제 시 발생하는 SQL**은 어떻게 달라지나요?
  - A안 - 값 타입이란 생명주기를 항상 엔티티에 의존하며, 해당 엔티티를 좀 더 **객체지향적이고 응집력 있게** 사용하는 것이 본래 목적이다. 그러나, 관계형 데이터 베이스에서는 컬렉션을 컬럼으로 저장할 수 없기 때문에 **값 타입 컬렉션**을 사용하면 별도의 테이블을 관리해야 하고, 그래서 수정할때는 모두 삭제했다가 다시 추가하고, 삭제할때는 n건의 삭제 쿼리가 발생할 것으로 보인다. B안에서는 AddressHistory를 값타입을 엔티티로 만든 케이스이다. 일대다 이기 때문에 추가 update 쿼리가 발생은 할 것 같다.
  > **피드백**: A안의 "모두 삭제 후 다시 추가" 동작을 정확히 짚었습니다. 이는 값 타입 컬렉션에 식별자(PK)가 없어 특정 행만 타겟팅하기 어렵기 때문입니다. B안의 "추가 update 쿼리"도 맞는데, 좀 더 구체적으로는 일대다 단방향의 경우 외래키가 자식 테이블에 있어 **INSERT 후 FK를 세팅하는 UPDATE**가 추가 발생합니다. 반면 수정/삭제 시에는 엔티티에 PK가 있으므로 해당 행만 정확히 `WHERE id = ?`로 처리된다는 점을 대비하면 A안과의 차이가 더 선명해집니다.

- 실무에서 어떤 기준으로 선택하실 건가요?
  - B안을 우선적으로 사용하긴 할 것 같으나, B안에서 관계를 좀더 바꿔 ManyToOne 형태로 만드는게 베스트이지 않을까 생각이 든다.
  > **피드백**: 좋은 판단입니다. `@OneToMany` 단방향보다 자식 엔티티 쪽에 `@ManyToOne`을 두는 양방향(혹은 다대일 단방향)이 FK를 자식이 직접 관리하므로 추가 UPDATE 없이 깔끔합니다. 여기에 "데이터가 단순하고 변경이 거의 없는 경우(예: ENUM 성격의 소수 값)"에만 A안을 고려한다는 기준을 추가하면 더 완성도 있는 답변이 됩니다.


---

### Q2. 임베디드 타입과 불변 객체

임베디드 타입(`@Embeddable`)은 여러 엔티티에서 공유하면 사이드 이펙트가 발생할 수 있다고 합니다.
이를 방지하기 위해 "불변 객체로 만들어야 한다"고 하는데,

- 불변 객체로 만들면 값을 변경하고 싶을 때는 어떻게 해야 할까요?
  - 해당 객체의 다른 신규 인스턴스를 `clone()`하는 식으로 만드는 방법이 있다. 그래서 각기 다른 인스턴스를 참조하도록 한다.
  > **피드백**: 의도는 맞지만 표현을 다듬으면 좋겠습니다. `clone()`은 Java의 `Cloneable` 인터페이스와 연관되어 얕은 복사/깊은 복사 이슈가 있으므로, 실무에서는 **새 인스턴스를 생성자로 만들어 통째로 교체**하는 방식이 더 일반적입니다. 예: `member.setAddress(new Address("newCity", "newStreet", "newZipcode"))`. 불변 객체이므로 "수정"이 아니라 "교체"라는 점이 핵심입니다.

- 본인이 실무에서 Address 같은 임베디드 타입을 설계한다면 어떻게 하실건가요?
  - setter를 만들지 않고 불변객체로 만들 것이다.
  > **피드백**: 핵심을 잘 짚었습니다. Kotlin이라면 `data class`의 `val` 프로퍼티로 자연스럽게 불변이 보장되고, `copy()`로 일부 필드만 바꾼 새 인스턴스를 만들 수 있어서 더 편리합니다. 추가로 `equals()`/`hashCode()` 재정의도 값 타입의 동등성 비교를 위해 중요한데, Kotlin `data class`는 이것도 자동 생성해주므로 실무에서 임베디드 타입과 궁합이 좋습니다.


---


## (Optional) 자유 토론 주제
9장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.

* middle / account 코드를 다루던 당시에 느낀 것이 있는데, lombok으로 객체 @getter와 @setter 를 모두 열어두고 생성자 / 팩토리 패턴이 아닌 해당 객체를 사용하는 매 서비스로직마다 일일이 set을 해주던 코드가 기억나는데, 디버깅할때 상당히 어렵고 골치 아팠다. jpa의 값 객체 뿐만 아니라 정말 필요한게 아니라면 불변하게 만드는게 좋은 것 같다.
  > **피드백**: 실무 경험에서 우러나온 좋은 인사이트입니다. setter가 열려있으면 "어디서든 값이 바뀔 수 있다"는 의미이므로 버그 발생 시 변경 지점 추적이 어려워지죠. 9장의 값 타입 불변 원칙이 사실 도메인 객체 전반에 적용되는 좋은 설계 원칙이라는 점을 잘 연결하셨습니다.
