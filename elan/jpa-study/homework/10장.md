# 10장 과제 – 객체지향 쿼리 언어

아래 질문들에 대해 각자의 의견을 정리해 주세요.

---

### Q1. 묵시적 조인의 위험성

아래 JPQL에서 실제로 나가는 SQL은 무엇인가요?

```
select m.team.name from Member m
```

> select t.name from Member m inner join Team t on m.team_id = t.id


- 왜 이런 묵시적 조인이 위험할까요?
  > jpql 을 보면 조인이 일어나는것 처럼 보이지 않지만, 경로탐색으로 인해 내부조인이 발생하게 됩니다.

- 본인이라면 실무에서 어떻게 작성하실 건가요?`
  > 위 연관 속성이 필요하다면 명확하게 조인을 명시하는게 좋습니다.

---

### Q2. fetch 조인과 값 타입

- 임베디드 타입(`@Embedded`)으로 설계된 필드는 fetch 조인이 필요한가요?
  > 필요 없습니다. 값 타입으로 엔티티에 포함됩니다.

- 엔티티 연관관계와 비교하여, 조회 시점의 동작 차이를 설명해주세요.
  > 연관관계에서 지연로딩으로 설정된다면 프록시 객체로 연관관계의 객체의 정보를 사용할때 조회를 하지만
  > fetch 조인을 사용하게 되면 SQL 에서 join 을 통해 한번에 가져올수 있습니다.
  > 상황에 따라 조회의 횟수가 늘어날수 있기때문에 한번에 조회를 해야한다면 성능 최적화를 위해 사용해야 할수 있어요.  

---

### Q3. 벌크 연산과 영속성 컨텍스트

- 아래 코드의 문제점은 무엇인가요?
  > 벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리르 날립기 때문에 영속성 컨텍스트에 있는 과거 데이터가 출력됩니다.

- 어떻게 해결하실 건가요?
  > 벌크 연산을 먼저 수행하고 엔티티를 조회하거나 영속성을 초기화(em.clear()) 합니다.

```kotlin
val member = em.find(Member::class.java, 1L)
// member.age == 20

em.createQuery("update Member m set m.age = m.age + 1")
    .executeUpdate()

println(member.age)
```

---

## (Optional) 자유 토론 주제
9장을 읽으며 추가로 고민한 점이나 토론하고 싶은 주제가 있다면 자유롭게 작성해주세요.